$date
	Tue Dec 13 16:40:30 2022
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module TESTBED $end
$var wire 1 ! rst_n $end
$var wire 1 " out_valid $end
$var wire 1 # mem_wen $end
$var wire 32 $ mem_dout [31:0] $end
$var wire 32 % mem_din [31:0] $end
$var wire 12 & mem_addr [11:0] $end
$var wire 32 ' inst_addr [31:0] $end
$var wire 32 ( inst [31:0] $end
$var wire 1 ) in_valid $end
$var wire 1 * clk $end
$var integer 32 + i [31:0] $end
$scope module My_MEM $end
$var wire 1 , CEN $end
$var wire 1 - OEN $end
$var wire 1 . _CEN $end
$var wire 1 / _CLK $end
$var wire 1 0 _OEN $end
$var wire 1 1 _OENi $end
$var wire 32 2 _Q [31:0] $end
$var wire 1 3 _WEN $end
$var wire 1 4 re_flag $end
$var wire 1 5 re_data_flag $end
$var wire 32 6 _D [31:0] $end
$var wire 12 7 _A [11:0] $end
$var wire 1 # WEN $end
$var wire 32 8 Q [31:0] $end
$var wire 32 9 D [31:0] $end
$var wire 1 * CLK $end
$var wire 12 : A [11:0] $end
$var parameter 32 ; BITS $end
$var parameter 32 < addr_width $end
$var parameter 12 = addrx $end
$var parameter 32 > word_depth $end
$var parameter 32 ? wordx $end
$var reg 12 @ Ai [11:0] $end
$var reg 1 A CENi $end
$var reg 32 B Di [31:0] $end
$var reg 1 C LAST_CLK $end
$var reg 12 D LAST_NOT_A [11:0] $end
$var reg 1 E LAST_NOT_CEN $end
$var reg 1 F LAST_NOT_CLK_MINH $end
$var reg 1 G LAST_NOT_CLK_MINL $end
$var reg 1 H LAST_NOT_CLK_PER $end
$var reg 32 I LAST_NOT_D [31:0] $end
$var reg 1 J LAST_NOT_WEN $end
$var reg 32 K LAST_Qi [31:0] $end
$var reg 12 L LATCHED_A [11:0] $end
$var reg 1 M LATCHED_CEN $end
$var reg 32 N LATCHED_D [31:0] $end
$var reg 1 O LATCHED_WEN $end
$var reg 12 P NOT_A [11:0] $end
$var reg 1 Q NOT_A0 $end
$var reg 1 R NOT_A1 $end
$var reg 1 S NOT_A10 $end
$var reg 1 T NOT_A11 $end
$var reg 1 U NOT_A2 $end
$var reg 1 V NOT_A3 $end
$var reg 1 W NOT_A4 $end
$var reg 1 X NOT_A5 $end
$var reg 1 Y NOT_A6 $end
$var reg 1 Z NOT_A7 $end
$var reg 1 [ NOT_A8 $end
$var reg 1 \ NOT_A9 $end
$var reg 1 ] NOT_CEN $end
$var reg 1 ^ NOT_CLK_MINH $end
$var reg 1 _ NOT_CLK_MINL $end
$var reg 1 ` NOT_CLK_PER $end
$var reg 32 a NOT_D [31:0] $end
$var reg 1 b NOT_D0 $end
$var reg 1 c NOT_D1 $end
$var reg 1 d NOT_D10 $end
$var reg 1 e NOT_D11 $end
$var reg 1 f NOT_D12 $end
$var reg 1 g NOT_D13 $end
$var reg 1 h NOT_D14 $end
$var reg 1 i NOT_D15 $end
$var reg 1 j NOT_D16 $end
$var reg 1 k NOT_D17 $end
$var reg 1 l NOT_D18 $end
$var reg 1 m NOT_D19 $end
$var reg 1 n NOT_D2 $end
$var reg 1 o NOT_D20 $end
$var reg 1 p NOT_D21 $end
$var reg 1 q NOT_D22 $end
$var reg 1 r NOT_D23 $end
$var reg 1 s NOT_D24 $end
$var reg 1 t NOT_D25 $end
$var reg 1 u NOT_D26 $end
$var reg 1 v NOT_D27 $end
$var reg 1 w NOT_D28 $end
$var reg 1 x NOT_D29 $end
$var reg 1 y NOT_D3 $end
$var reg 1 z NOT_D30 $end
$var reg 1 { NOT_D31 $end
$var reg 1 | NOT_D4 $end
$var reg 1 } NOT_D5 $end
$var reg 1 ~ NOT_D6 $end
$var reg 1 !" NOT_D7 $end
$var reg 1 "" NOT_D8 $end
$var reg 1 #" NOT_D9 $end
$var reg 1 $" NOT_WEN $end
$var reg 32 %" Qi [31:0] $end
$var reg 1 &" WENi $end
$scope function valid_address $end
$var reg 12 '" a [11:0] $end
$upscope $end
$scope task latch_inputs $end
$upscope $end
$scope task mem_cycle $end
$upscope $end
$scope task process_violations $end
$upscope $end
$scope task read_mem $end
$var reg 1 (" r_wb $end
$var reg 1 )" xflag $end
$upscope $end
$scope task update_last_notifiers $end
$upscope $end
$scope task update_logic $end
$upscope $end
$scope task update_notifier_buses $end
$upscope $end
$scope task write_mem $end
$var reg 12 *" a [11:0] $end
$var reg 32 +" d [31:0] $end
$upscope $end
$scope task write_mem_x $end
$var reg 12 ," a [11:0] $end
$upscope $end
$scope task x_inputs $end
$var integer 32 -" n [31:0] $end
$upscope $end
$scope task x_mem $end
$var integer 32 ." n [31:0] $end
$upscope $end
$upscope $end
$scope module My_PATTERN $end
$var wire 1 " out_valid $end
$var wire 32 /" inst_addr [31:0] $end
$var reg 1 * clk $end
$var reg 1 ) in_valid $end
$var reg 32 0" inst [31:0] $end
$var reg 1 ! rst_n $end
$var real 1 1" CYCLE $end
$var integer 32 2" func [31:0] $end
$var integer 32 3" golden_inst_addr [31:0] $end
$var integer 32 4" i [31:0] $end
$var integer 32 5" immediate [31:0] $end
$var integer 32 6" opcode [31:0] $end
$var integer 32 7" out_counter [31:0] $end
$var integer 32 8" out_max_latency [31:0] $end
$var integer 32 9" pat [31:0] $end
$var integer 32 :" pat_num [31:0] $end
$var integer 32 ;" rd [31:0] $end
$var integer 32 <" rs [31:0] $end
$var integer 32 =" rt [31:0] $end
$var integer 32 >" seed [31:0] $end
$var integer 32 ?" shamt [31:0] $end
$var integer 32 @" t [31:0] $end
$scope task check_ans_task $end
$upscope $end
$scope task check_memory_task $end
$upscope $end
$scope task display_fail_task $end
$upscope $end
$scope task display_pass_task $end
$upscope $end
$scope task input_task $end
$upscope $end
$scope task out_valid_wait_task $end
$upscope $end
$scope task reset_check_task $end
$upscope $end
$upscope $end
$scope module My_SP $end
$var wire 1 * clk $end
$var wire 1 ) in_valid $end
$var wire 32 A" inst [31:0] $end
$var wire 32 B" mem_dout [31:0] $end
$var wire 1 ! rst_n $end
$var reg 32 C" inst_addr [31:0] $end
$var reg 12 D" mem_addr [11:0] $end
$var reg 32 E" mem_din [31:0] $end
$var reg 1 # mem_wen $end
$var reg 1 " out_valid $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 F" \r[0] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 G" \r[1] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 H" \r[2] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 I" \r[3] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 J" \r[4] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 K" \r[5] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 L" \r[6] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 M" \r[7] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 N" \r[8] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 O" \r[9] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 P" \r[10] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 Q" \r[11] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 R" \r[12] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 S" \r[13] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 T" \r[14] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 U" \r[15] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 V" \r[16] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 W" \r[17] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 X" \r[18] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 Y" \r[19] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 Z" \r[20] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 [" \r[21] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 \" \r[22] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 ]" \r[23] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 ^" \r[24] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 _" \r[25] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 `" \r[26] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 a" \r[27] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 b" \r[28] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 c" \r[29] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 d" \r[30] [31:0] $end
$upscope $end
$upscope $end
$scope module TESTBED $end
$scope module My_SP $end
$var reg 32 e" \r[31] [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
bx ?
b1000000000000 >
bx =
b1100 <
b100000 ;
$end
#0
$dumpvars
bx e"
bx d"
bx c"
bx b"
bx a"
bx `"
bx _"
bx ^"
bx ]"
bx \"
bx ["
bx Z"
bx Y"
bx X"
bx W"
bx V"
bx U"
bx T"
bx S"
bx R"
bx Q"
bx P"
bx O"
bx N"
bx M"
bx L"
bx K"
bx J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
bx B"
bx A"
bx @"
bx ?"
b1000000 >"
bx ="
bx <"
bx ;"
b101000101 :"
bx 9"
b1010 8"
bx 7"
bx 6"
bx 5"
b100000 4"
b0 3"
bx 2"
r10 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
bx +"
bx *"
x)"
x("
bx '"
x&"
bx %"
x$"
x#"
x""
x!"
x~
x}
x|
x{
xz
xy
xx
xw
xv
xu
xt
xs
xr
xq
xp
xo
xn
xm
xl
xk
xj
xi
xh
xg
xf
xe
xd
xc
xb
bx a
x`
x_
x^
x]
x\
x[
xZ
xY
xX
xW
xV
xU
xT
xS
xR
xQ
bx P
xO
bx N
xM
bx L
bx K
xJ
bx I
xH
xG
xF
xE
bx D
0C
bx B
xA
bx @
bx :
bx 9
bx 8
bx 7
bx 6
x5
14
x3
bx 2
01
00
0/
0.
0-
0,
b100000 +
0*
0)
bx (
bx '
bx &
bx %
bx $
x#
x"
1!
$end
#500
0*
#1000
0!
#2000
1!
#4000
